% % % % %  mod_add  模加 

% function z1 = mod_add(x,y)%输入位64位16进制数据

% x='8454ABDEE1355A4CB4D5E2D36EB4F698AD7E1C3BAD5A6CCBB1564987F98CBACC';%64
% y='8659ADCBCE65FA68CDEBA465ACB449E8B8F89AD9BCA48321BC4E65A4BCF46A6E';
x='c000000000000000000000000000000000000000000000000000000000000000';
y='f000000000000000000000000000000000000000000000000000000000000000';
%   P='8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3';%64
P='8000000000000000000000000000000000000000000000000000000000000000';
p_f='f000000000000000000000000000000000000000000000000000000000000000';
p_1='1000000000000000000000000000000000000000000000000000000000000000';
z=data_add(x,y);

P1=['0',P];%添加字符0在P前
L=strlength(z);
for i=1:L
    if(z(i)>P1(i))
         if (z(i+1)>P(i))
            z4=data_reduce(z(2:end),P);
            if (z4(i)>P(i))
                z4=data_reduce(z4,P);
            elseif (z4(i)<P(i))
                 z1=z4;      %还有问题     
                break
            elseif (z4(i)==P1(i))
                z1='0000000000000000000000000000000000000000000000000000000000000000';
            end 
         elseif (z(i+1)<P(i))
             z5=data_reduce(p_f,P);
             z6=data_add(z5,z(2:end))
             z7=data_add(z6,p_1);
             if (z7(i)>P(i))
                 z1=data_reduce(z6,P);
                 break
             elseif (z7(i)<P(i))
                 z1=z7;
                 break
             elseif (z7(i)==P(i))
                 z1='0000000000000000000000000000000000000000000000000000000000000000';
             end
         elseif(z(i+1)==P(i))
             z1='0000000000000000000000000000000000000000000000000000000000000000';
         end
%         z1 =z0;
    elseif(z(i)==P1(i))
        z1='0000000000000000000000000000000000000000000000000000000000000000';

    elseif(z(i)<P1(i))
        z3=z;
        z1=z3(2:end);%截z3从第二位到最后一位赋值给z1
        break
    
    end
end


% z2=data_add(z1,P);