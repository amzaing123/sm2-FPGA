`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 2024/10/09 10:35:52
// Design Name: 
// Module Name: montgomery_mul_2
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module montgomery_mul_2(
input clk,
input rst_n,
input [255:0] x,
input [255:0] y,
output [255:0]result,
output result_valid
    );
wire [255:0] x_common;
wire [255:0] y_common;
wire [511:0] z_common;	

wire [255:0] x_common1;
wire [255:0] y_common1;
wire [511:0] z_common1;

wire [255:0] x_common2;
wire [255:0] y_common2;
wire [511:0] z_common2;
wire b4_valid;

reg [255:0] x_temp;
reg [255:0] y_temp;	

reg [255:0] x_temp1;
reg [255:0] y_temp1;
reg [1:0]state1;//x
reg [512:0] x3;
reg [256:0] x4;
reg [256:0] x5;
wire [256:0] x5_1;
reg [1:0]state3;//y
reg [512:0] y3;
reg [256:0] y4;
reg [256:0] y5;
wire [256:0] y5_1;

reg y_valid;	
parameter P=256'h8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3;
parameter P_1=256'hACE8C019117B91A87C85E2872C08DD0D3B8465BC9C2E9D06A2A0380C50F77715;  // (-P^-1)mod_R	
parameter R2=256'h0AE55229283CD96AEE4D87DA90D8C66CEB372DA83FC9C6363D579C46F6DE18F2;
//乘法器复位
reg double_rst;
integer cnt_double;
always@ (posedge clk or negedge rst_n)
begin
	if (~rst_n)
	begin
		double_rst <= 0;
		cnt_double <= 0;
		//result_temp <=0;
	end
	else if (cnt_double < 5)
	begin
		cnt_double =cnt_double +1;
		double_rst <=0;
	end
	//999-45399最慢
	else if (4 <cnt_double && cnt_double <780)//45399 15499 1549
	begin
		double_rst <= 1;
		cnt_double <= cnt_double +1;
		
	end
	
	else if  (cnt_double ==780)
	begin
			cnt_double <=0;
			double_rst <=0;
	end

end
wire mult_rst =double_rst;
wire b1_valid;
///////求x*R2
mult256 mult256_1 (
	.clk(clk),
    .rst_n(mult_rst),
	.str1(x_common),
	.str2(y_common),
	.b(z_common),//
	.b_valid(b1_valid)
  );
////////求y *R2
mult256 mult256_2 (
	.clk(clk),
    .rst_n(mult_rst),
	.str1(x_common1),
	.str2(y_common1),
	.b(z_common1),//
	.b_valid(b2_valid)
  );
wire xy_valid;
//////进行两次约减
mult256 mult256_3 (
	.clk(clk),
    .rst_n(xy_valid),
	.str1(x_common2),
	.str2(y_common2),
	.b(z_common2),//
	.b_valid(b4_valid)
  );
reg b1_valid_temp;
reg b3_valid_temp;
wire b3_valid;
reg [1:0]cnt;
reg [1:0]state;//x
wire b_valid1;
wire b_valid;
reg [1:0]cnt1;//y
reg b2_valid_temp;
wire by_valid1;
wire by_valid;

reg [1:0]cnt2;//约减
reg b4_valid_temp;
wire b_valid4;
wire b4_valid4;
always@(posedge clk or negedge rst_n)
begin
	if (~rst_n)
	begin
		b1_valid_temp<=0;//x
		b2_valid_temp<=0;//y
		b4_valid_temp<=0;
	end
	else begin
		b1_valid_temp<=b1_valid;//x
		b2_valid_temp<=b2_valid;//y
		b4_valid_temp<=b4_valid;
	end
end
assign b_valid1 = b1_valid ^b1_valid_temp;
assign b_valid = b_valid1 && b1_valid;//x
assign by_valid1 = b2_valid ^b2_valid_temp;
assign by_valid = by_valid1 && b2_valid;//y
assign b_valid4 = b4_valid ^b4_valid_temp;
assign b4_valid4 = b_valid4 && b4_valid;//约减

always@(posedge clk or negedge rst_n)
begin
	if (~rst_n)
	begin
		cnt<=2'd0;
		cnt1<=2'd0;
		cnt2<=2'd0;
	end
	else
	begin
		if (b_valid ==1 && cnt <3)//x
			cnt<=cnt+1;
		else if (cnt ==3)
			cnt <=0;
		if (by_valid ==1 && cnt1 <3)//y
			cnt1<=cnt1+1;
		else if (cnt1 ==3)
			cnt1 <=0;
		if (b4_valid4 ==1 && cnt2 <3)//y
			cnt2<=cnt2+1;
		else if (cnt2 ==3)
			cnt2 <=0;
	end
end
///x*R2状态机
reg [255:0] z_temp;
reg [511:0] mp_x1;
reg [511:0] temp1;

reg [255:0] z_temp1;
reg [511:0] mp_y1;
reg [511:0] temp1_y;
reg [1:0]state2;
reg b6_valid_temp;

reg [1:0]state4;//约减
reg [255:0] Ax_temp;
reg [255:0] Ay_temp;
reg [255:0] Az_temp;
reg [511:0] mp_A1;
reg [511:0] tempA;
reg b5_valid_temp;
always@(posedge clk or negedge rst_n)
begin
	if (~rst_n)
	begin
		state4<=2'd0;
			Ax_temp<=256'd0;
			Ay_temp<=256'd0;
			Az_temp<=256'd0;			
			mp_A1 <=512'd0;
			tempA <=512'd0;
			b5_valid_temp<=0;
	end
	else
	begin
		case(state4)
		2'd0:begin
						Ax_temp<=y5_1[255:0];
						Ay_temp<=x5_1[255:0];
			if (b4_valid4 ==1 && cnt2==0)//
					begin
						state4<=2'd1;
						Az_temp<=z_common2[255:0];
						tempA <=z_common2;
					end
		end
		2'd1:begin
			Ax_temp<=P_1;
			Ay_temp<=Az_temp;
			if (b4_valid4 ==1 && cnt2==1)//
					begin
						state4<=2'd2;
						Az_temp<=z_common2[255:0];						
					end
		end
		2'd2:begin
			Ax_temp<=Az_temp;
			Ay_temp<=P;
			if (b4_valid4 ==1 && cnt2==2)//X
					begin
						b5_valid_temp <=1;
						mp_A1 <=z_common2;
					end
		end
		endcase
	end
end
assign x_common2 =Ax_temp;//
assign y_common2 =Ay_temp;

wire b5_valid;
assign b5_valid =b5_valid_temp;
wire [511:0] tempA1;
wire [511:0] mp_A;
assign tempA1 =tempA;
assign mp_A =mp_A1;
always@(posedge clk or negedge rst_n)
begin
	if (~rst_n)
		begin
		//x*R2状态机
			state<=2'd0;
			x_temp<=256'd0;
			y_temp<=256'd0;
			z_temp<=256'd0;			
			mp_x1 <=512'd0;
			temp1 <=512'd0;
			b3_valid_temp<=0;
		//y状态机 
			state2<=2'd0;
			x_temp1<=256'd0;
			y_temp1<=256'd0;
			z_temp1<=256'd0;
			temp1_y <=512'd0;
			mp_y1<=512'd0;
			b6_valid_temp <=0;		
		end

	else
		begin
			case(state)
			2'd0:begin
					x_temp<=x;//x
					y_temp<=R2;
					x_temp1<=y;//y
					y_temp1<=R2;				
				if (b_valid ==1 && cnt==0)//x
					begin
						state<=2'd1;
						z_temp <=z_common[255:0];
						temp1 <=z_common;
					end
				if (by_valid ==1 && cnt1==0)//y
					begin
						state2<=2'd1;
						z_temp1 <=z_common1[255:0];
						temp1_y <=z_common1;
					end
			end
			2'd1:begin					
					x_temp<=P_1;//x
					y_temp<=z_temp;
					x_temp1<=P_1;//y
					y_temp1<=z_temp1;
					if (b_valid ==1 && cnt==1)//x
					begin
						state<=2'd2;
						z_temp <=z_common[255:0];
					end
					if (by_valid ==1 && cnt1==1)//y
					begin
						state2<=2'd2;
						z_temp1 <=z_common1[255:0];						
					end
			end
			2'd2:begin
					x_temp<=z_temp;//x
					y_temp<=P;
					x_temp1<=z_temp1;//y
					y_temp1<=P;
					if (b_valid ==1 && cnt==2)//X
					begin
						b3_valid_temp <=1;
						mp_x1 <=z_common;
					end
					if (by_valid ==1 && cnt1==2)//Y
					begin
						b6_valid_temp <=1;
						mp_y1 <=z_common1;
					end
			end
			endcase

		end

end
assign x_common =x_temp;//x
assign y_common =y_temp;
assign b3_valid =b3_valid_temp;
wire [511:0] temp;
wire [511:0] mp_x;
assign temp =temp1;
assign mp_x =mp_x1;



reg x_valid;
reg [256:0]P1;
always@(posedge clk or negedge b3_valid)
 begin
		if (~b3_valid)
		begin
			x3 <=513'd0;
			x4 <= 257'd0;
			x5 <= 257'd0;
			x_valid <=0;
			state1 <= 2'd0;
			P1 <=257'd0;
		end
		else 
		begin
			case(state1)
				2'd0:begin//
						 x3 <= temp + mp_x;
						 state1 <= 2'd1;
					end
				2'd1:begin
						 x4 <= x3[512:256];
						 P1 <= {0,P};
						 state1 <=2'd2;
				end	
				2'd2:begin 
						if (x4 > P1)
							begin
								x5 <= {0,(x4 -P)};
								x_valid <=1;
							end
						  else
							begin
								x5 <= x4;
								x_valid <=1;
							end
					end
			endcase
		end
end
assign x5_1 = x5;
assign x_common1 =x_temp1;//y
assign y_common1 =y_temp1;
wire b6_valid;
assign b6_valid =b6_valid_temp;
wire [511:0] temp2;
wire [511:0] mp_y;
assign temp2 =temp1_y;
assign mp_y =mp_y1;



always@(posedge clk or negedge b6_valid)
 begin
		if (~b6_valid)
		begin
			y3 <=513'd0;
			y4 <= 257'd0;
			y5 <= 257'd0;
			y_valid <=0;
			state3 <=0;
		end
		else 
		begin
			case(state3)
				2'd0:begin
						y3 <= temp2 + mp_y;
						state3 <=2'd1;
					end
				2'd1:begin
						y4 <= y3[512:256];
						state3 <=2'd2;
					end
				2'd2:begin
						 if (y4 > P1)
							begin
								y5 <= {0,(y4 -P)};
								y_valid <=1;
							end
						  else
							begin
								y5 <= y4;
								y_valid <=1;
							end
					end
			endcase
		end
end
assign xy_valid =  x_valid && y_valid && mult_rst;
assign y5_1 =y5;
reg [1:0]state5;
reg [512:0] A3;
reg [256:0] A4;
reg [256:0] A5;
wire [256:0] A5_1;
wire A1_valid;
reg A_valid;
always@(posedge clk or negedge b5_valid)
 begin
		if (~b5_valid)
		begin
			A3 <=513'd0;
			A4 <= 257'd0;
			A5 <= 257'd0;
			A_valid <=0;
			state5 <=0;
		end
		else 
		begin
			case(state5)
				2'd0:begin
						A3 <= tempA1 + mp_A;
						state5 <=2'd1;
					 end
				2'd1:begin
						A4 <= A3[512:256];
					 //P1 <= {0,P};
					 state5 <=2'd2;
					end
				2'd2:begin
						 if (A4 > P1)
							begin
								A5 <= {0,(A4 -P)};
								A_valid <=1;
							end
						  else
							begin
								A5 <= A4;
								A_valid <=1;
							end
					end
			endcase
		end
end
assign A5_1 = A5;
assign A1_valid = A_valid;



















assign result =z_common[255:0];
assign result_valid =b3_valid;


	
	
	
	
	
	
	
	
	
	
	
	
endmodule
